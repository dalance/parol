// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

#![allow(clippy::all)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::id_tree::Tree;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};

use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

use std::marker::PhantomData;

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ParolLsGrammarTrait {
    /// Semantic action for non-terminal 'ParolLs'
    fn parol_ls(&mut self, _arg: &ParolLs) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Prolog'
    fn prolog(&mut self, _arg: &Prolog) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StartDeclaration'
    fn start_declaration(&mut self, _arg: &StartDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Declaration'
    fn declaration(&mut self, _arg: &Declaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerDirectives'
    fn scanner_directives(&mut self, _arg: &ScannerDirectives) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GrammarDefinition'
    fn grammar_definition(&mut self, _arg: &GrammarDefinition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DoubleColon'
    fn double_colon(&mut self, _arg: &DoubleColon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProductionLHS'
    fn production_l_h_s(&mut self, _arg: &ProductionLHS) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Production'
    fn production(&mut self, _arg: &Production) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Alternations'
    fn alternations(&mut self, _arg: &Alternations) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Alternation'
    fn alternation(&mut self, _arg: &Alternation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Symbol'
    fn symbol(&mut self, _arg: &Symbol) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenLiteral'
    fn token_literal(&mut self, _arg: &TokenLiteral) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SimpleToken'
    fn simple_token(&mut self, _arg: &SimpleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenWithStates'
    fn token_with_states(&mut self, _arg: &TokenWithStates) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Group'
    fn group(&mut self, _arg: &Group) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Optional'
    fn optional(&mut self, _arg: &Optional) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Repeat'
    fn repeat(&mut self, _arg: &Repeat) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NonTerminal'
    fn non_terminal(&mut self, _arg: &NonTerminal) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Identifier'
    fn identifier(&mut self, _arg: &Identifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LiteralString'
    fn literal_string(&mut self, _arg: &LiteralString) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerState'
    fn scanner_state(&mut self, _arg: &ScannerState) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StateList'
    fn state_list(&mut self, _arg: &StateList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerSwitch'
    fn scanner_switch(&mut self, _arg: &ScannerSwitch) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ASTControl'
    fn a_s_t_control(&mut self, _arg: &ASTControl) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CutOperator'
    fn cut_operator(&mut self, _arg: &CutOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UserTypeDeclaration'
    fn user_type_declaration(&mut self, _arg: &UserTypeDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UserTypeName'
    fn user_type_name(&mut self, _arg: &UserTypeName) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comments'
    fn comments(&mut self, _arg: &Comments) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LineComment'
    fn line_comment(&mut self, _arg: &LineComment) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BlockComment'
    fn block_comment(&mut self, _arg: &BlockComment) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Regex'
    fn regex(&mut self, _arg: &Regex) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 7
///
/// Declaration: "%title" : OwnedToken String Comments;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationPercentTitleStringComments {
    pub percent_title: crate::parol_ls_grammar::OwnedToken, /* %title */
    pub string: Box<String>,
    pub comments: Box<Comments>,
}

///
/// Type derived for production 8
///
/// Declaration: "%comment" : OwnedToken String Comments;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationPercentCommentStringComments {
    pub percent_comment: crate::parol_ls_grammar::OwnedToken, /* %comment */
    pub string: Box<String>,
    pub comments: Box<Comments>,
}

///
/// Type derived for production 9
///
/// Declaration: "%user_type" : OwnedToken Identifier "=" : OwnedToken UserTypeName Comments;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationPercentUserUnderscoreTypeIdentifierEquUserTypeNameComments {
    pub percent_user_underscore_type: crate::parol_ls_grammar::OwnedToken, /* %user_type */
    pub identifier: Box<Identifier>,
    pub equ: crate::parol_ls_grammar::OwnedToken, /* = */
    pub user_type_name: Box<UserTypeName>,
    pub comments: Box<Comments>,
}

///
/// Type derived for production 10
///
/// Declaration: ScannerDirectives;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationScannerDirectives {
    pub scanner_directives: Box<ScannerDirectives>,
}

///
/// Type derived for production 11
///
/// ScannerDirectives: "%line_comment" : OwnedToken TokenLiteral Comments;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerDirectivesPercentLineUnderscoreCommentTokenLiteralComments {
    pub percent_line_underscore_comment: crate::parol_ls_grammar::OwnedToken, /* %line_comment */
    pub token_literal: Box<TokenLiteral>,
    pub comments: Box<Comments>,
}

///
/// Type derived for production 12
///
/// ScannerDirectives: "%block_comment" : OwnedToken TokenLiteral TokenLiteral Comments;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerDirectivesPercentBlockUnderscoreCommentTokenLiteralTokenLiteralComments {
    pub percent_block_underscore_comment: crate::parol_ls_grammar::OwnedToken, /* %block_comment */
    pub token_literal: Box<TokenLiteral>,
    pub token_literal0: Box<TokenLiteral>,
    pub comments: Box<Comments>,
}

///
/// Type derived for production 13
///
/// ScannerDirectives: "%auto_newline_off" : OwnedToken Comments;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerDirectivesPercentAutoUnderscoreNewlineUnderscoreOffComments {
    pub percent_auto_underscore_newline_underscore_off: crate::parol_ls_grammar::OwnedToken, /* %auto_newline_off */
    pub comments: Box<Comments>,
}

///
/// Type derived for production 14
///
/// ScannerDirectives: "%auto_ws_off" : OwnedToken Comments;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerDirectivesPercentAutoUnderscoreWsUnderscoreOffComments {
    pub percent_auto_underscore_ws_underscore_off: crate::parol_ls_grammar::OwnedToken, /* %auto_ws_off */
    pub comments: Box<Comments>,
}

///
/// Type derived for production 27
///
/// Factor: Group;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorGroup {
    pub group: Box<Group>,
}

///
/// Type derived for production 28
///
/// Factor: Repeat;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorRepeat {
    pub repeat: Box<Repeat>,
}

///
/// Type derived for production 29
///
/// Factor: Optional;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorOptional {
    pub optional: Box<Optional>,
}

///
/// Type derived for production 30
///
/// Factor: Symbol;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorSymbol {
    pub symbol: Box<Symbol>,
}

///
/// Type derived for production 31
///
/// Symbol: NonTerminal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolNonTerminal {
    pub non_terminal: Box<NonTerminal>,
}

///
/// Type derived for production 32
///
/// Symbol: SimpleToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolSimpleToken {
    pub simple_token: Box<SimpleToken>,
}

///
/// Type derived for production 33
///
/// Symbol: TokenWithStates;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolTokenWithStates {
    pub token_with_states: Box<TokenWithStates>,
}

///
/// Type derived for production 34
///
/// Symbol: ScannerSwitch;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolScannerSwitch {
    pub scanner_switch: Box<ScannerSwitch>,
}

///
/// Type derived for production 35
///
/// TokenLiteral: String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenLiteralString {
    pub string: Box<String>,
}

///
/// Type derived for production 36
///
/// TokenLiteral: LiteralString;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenLiteralLiteralString {
    pub literal_string: Box<LiteralString>,
}

///
/// Type derived for production 37
///
/// TokenLiteral: Regex;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenLiteralRegex {
    pub regex: Box<Regex>,
}

///
/// Type derived for production 59
///
/// ScannerSwitch: "%sc" : OwnedToken "\(" : OwnedToken ScannerSwitchOpt /* Option */ "\)" : OwnedToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerSwitchPercentScLParenScannerSwitchOptRParen {
    pub percent_sc: crate::parol_ls_grammar::OwnedToken, /* %sc */
    pub l_paren: crate::parol_ls_grammar::OwnedToken,    /* \( */
    pub scanner_switch_opt: Option<Box<ScannerSwitchOpt>>,
    pub r_paren: crate::parol_ls_grammar::OwnedToken, /* \) */
}

///
/// Type derived for production 60
///
/// ScannerSwitch: "%push" : OwnedToken "\(" : OwnedToken Identifier "\)" : OwnedToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerSwitchPercentPushLParenIdentifierRParen {
    pub percent_push: crate::parol_ls_grammar::OwnedToken, /* %push */
    pub l_paren: crate::parol_ls_grammar::OwnedToken,      /* \( */
    pub identifier: Box<Identifier>,
    pub r_paren: crate::parol_ls_grammar::OwnedToken, /* \) */
}

///
/// Type derived for production 61
///
/// ScannerSwitch: "%pop" : OwnedToken "\(" : OwnedToken "\)" : OwnedToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerSwitchPercentPopLParenRParen {
    pub percent_pop: crate::parol_ls_grammar::OwnedToken, /* %pop */
    pub l_paren: crate::parol_ls_grammar::OwnedToken,     /* \( */
    pub r_paren: crate::parol_ls_grammar::OwnedToken,     /* \) */
}

///
/// Type derived for production 64
///
/// ASTControl: CutOperator;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ASTControlCutOperator {
    pub cut_operator: Box<CutOperator>,
}

///
/// Type derived for production 65
///
/// ASTControl: UserTypeDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ASTControlUserTypeDeclaration {
    pub user_type_declaration: Box<UserTypeDeclaration>,
}

///
/// Type derived for production 73
///
/// CommentsListGroup: LineComment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommentsListGroupLineComment {
    pub line_comment: Box<LineComment>,
}

///
/// Type derived for production 74
///
/// CommentsListGroup: BlockComment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommentsListGroupBlockComment {
    pub block_comment: Box<BlockComment>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal ASTControl
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTControl {
    CutOperator(ASTControlCutOperator),
    UserTypeDeclaration(ASTControlUserTypeDeclaration),
}

///
/// Type derived for non-terminal Alternation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Alternation {
    pub alternation_list: Vec<AlternationList>,
}

///
/// Type derived for non-terminal AlternationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlternationList {
    pub factor: Box<Factor>,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Alternations
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Alternations {
    pub alternation: Box<Alternation>,
    pub alternations_list: Vec<AlternationsList>,
}

///
/// Type derived for non-terminal AlternationsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlternationsList {
    pub or: crate::parol_ls_grammar::OwnedToken, /* \| */
    pub comments: Box<Comments>,
    pub alternation: Box<Alternation>,
}

///
/// Type derived for non-terminal BlockComment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BlockComment {
    pub block_comment: crate::parol_ls_grammar::OwnedToken, /* (?ms)/\u{2a}.*?\u{2a}/ */
}

///
/// Type derived for non-terminal Comments
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Comments {
    pub comments_list: Vec<CommentsList>,
}

///
/// Type derived for non-terminal CommentsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommentsList {
    pub comments_list_group: Box<CommentsListGroup>,
}

///
/// Type derived for non-terminal CommentsListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CommentsListGroup {
    LineComment(CommentsListGroupLineComment),
    BlockComment(CommentsListGroupBlockComment),
}

///
/// Type derived for non-terminal CutOperator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CutOperator {
    pub cut_operator: crate::parol_ls_grammar::OwnedToken, /* \^ */
}

///
/// Type derived for non-terminal Declaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Declaration {
    PercentTitleStringComments(DeclarationPercentTitleStringComments),
    PercentCommentStringComments(DeclarationPercentCommentStringComments),
    PercentUserUnderscoreTypeIdentifierEquUserTypeNameComments(
        DeclarationPercentUserUnderscoreTypeIdentifierEquUserTypeNameComments,
    ),
    ScannerDirectives(DeclarationScannerDirectives),
}

///
/// Type derived for non-terminal DoubleColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleColon {
    pub double_colon: crate::parol_ls_grammar::OwnedToken, /* :: */
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor {
    Group(FactorGroup),
    Repeat(FactorRepeat),
    Optional(FactorOptional),
    Symbol(FactorSymbol),
}

///
/// Type derived for non-terminal GrammarDefinition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GrammarDefinition {
    pub percent_percent: crate::parol_ls_grammar::OwnedToken, /* %% */
    pub production: Box<Production>,
    pub grammar_definition_list: Vec<GrammarDefinitionList>,
}

///
/// Type derived for non-terminal GrammarDefinitionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GrammarDefinitionList {
    pub production: Box<Production>,
}

///
/// Type derived for non-terminal Group
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Group {
    pub l_paren: crate::parol_ls_grammar::OwnedToken, /* \( */
    pub alternations: Box<Alternations>,
    pub r_paren: crate::parol_ls_grammar::OwnedToken, /* \) */
}

///
/// Type derived for non-terminal Identifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Identifier {
    pub identifier: crate::parol_ls_grammar::OwnedToken, /* [a-zA-Z_][a-zA-Z0-9_]* */
}

///
/// Type derived for non-terminal LineComment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LineComment {
    pub line_comment: crate::parol_ls_grammar::OwnedToken, /* //.*(:?\r\n|\r|\n|$) */
}

///
/// Type derived for non-terminal LiteralString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralString {
    pub literal_string: crate::parol_ls_grammar::OwnedToken, /* '(\\'|[^'])*?' */
}

///
/// Type derived for non-terminal NonTerminal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NonTerminal {
    pub identifier: Box<Identifier>,
    pub non_terminal_opt: Option<Box<NonTerminalOpt>>,
}

///
/// Type derived for non-terminal NonTerminalOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NonTerminalOpt {
    pub a_s_t_control: Box<ASTControl>,
}

///
/// Type derived for non-terminal Optional
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Optional {
    pub l_bracket: crate::parol_ls_grammar::OwnedToken, /* \[ */
    pub alternations: Box<Alternations>,
    pub r_bracket: crate::parol_ls_grammar::OwnedToken, /* \] */
}

///
/// Type derived for non-terminal ParolLs
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ParolLs {
    pub prolog: Box<Prolog>,
    pub grammar_definition: Box<GrammarDefinition>,
}

///
/// Type derived for non-terminal Production
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Production {
    pub production_l_h_s: Box<ProductionLHS>,
    pub alternations: Box<Alternations>,
    pub semicolon: crate::parol_ls_grammar::OwnedToken, /* ; */
}

///
/// Type derived for non-terminal ProductionLHS
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ProductionLHS {
    pub comments: Box<Comments>,
    pub identifier: Box<Identifier>,
    pub comments0: Box<Comments>,
    pub colon: crate::parol_ls_grammar::OwnedToken, /* : */
}

///
/// Type derived for non-terminal Prolog
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Prolog {
    pub start_declaration: Box<StartDeclaration>,
    pub prolog_list: Vec<PrologList>,
    pub prolog_list0: Vec<PrologList0>,
}

///
/// Type derived for non-terminal PrologList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrologList {
    pub declaration: Box<Declaration>,
}

///
/// Type derived for non-terminal PrologList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrologList0 {
    pub scanner_state: Box<ScannerState>,
}

///
/// Type derived for non-terminal Regex
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Regex {
    pub regex: crate::parol_ls_grammar::OwnedToken, /* /(\\/|[^/]|)*?/ */
}

///
/// Type derived for non-terminal Repeat
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Repeat {
    pub l_brace: crate::parol_ls_grammar::OwnedToken, /* \{ */
    pub alternations: Box<Alternations>,
    pub r_brace: crate::parol_ls_grammar::OwnedToken, /* \} */
}

///
/// Type derived for non-terminal ScannerDirectives
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScannerDirectives {
    PercentLineUnderscoreCommentTokenLiteralComments(
        ScannerDirectivesPercentLineUnderscoreCommentTokenLiteralComments,
    ),
    PercentBlockUnderscoreCommentTokenLiteralTokenLiteralComments(
        ScannerDirectivesPercentBlockUnderscoreCommentTokenLiteralTokenLiteralComments,
    ),
    PercentAutoUnderscoreNewlineUnderscoreOffComments(
        ScannerDirectivesPercentAutoUnderscoreNewlineUnderscoreOffComments,
    ),
    PercentAutoUnderscoreWsUnderscoreOffComments(
        ScannerDirectivesPercentAutoUnderscoreWsUnderscoreOffComments,
    ),
}

///
/// Type derived for non-terminal ScannerState
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerState {
    pub percent_scanner: crate::parol_ls_grammar::OwnedToken, /* %scanner */
    pub identifier: Box<Identifier>,
    pub l_brace: crate::parol_ls_grammar::OwnedToken, /* \{ */
    pub scanner_state_list: Vec<ScannerStateList>,
    pub r_brace: crate::parol_ls_grammar::OwnedToken, /* \} */
}

///
/// Type derived for non-terminal ScannerStateList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerStateList {
    pub scanner_directives: Box<ScannerDirectives>,
}

///
/// Type derived for non-terminal ScannerSwitch
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScannerSwitch {
    PercentScLParenScannerSwitchOptRParen(ScannerSwitchPercentScLParenScannerSwitchOptRParen),
    PercentPushLParenIdentifierRParen(ScannerSwitchPercentPushLParenIdentifierRParen),
    PercentPopLParenRParen(ScannerSwitchPercentPopLParenRParen),
}

///
/// Type derived for non-terminal ScannerSwitchOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerSwitchOpt {
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal SimpleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleToken {
    pub token_literal: Box<TokenLiteral>,
    pub simple_token_opt: Option<Box<SimpleTokenOpt>>,
}

///
/// Type derived for non-terminal SimpleTokenOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleTokenOpt {
    pub a_s_t_control: Box<ASTControl>,
}

///
/// Type derived for non-terminal StartDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StartDeclaration {
    pub comments: Box<Comments>,
    pub percent_start: crate::parol_ls_grammar::OwnedToken, /* %start */
    pub identifier: Box<Identifier>,
    pub comments0: Box<Comments>,
}

///
/// Type derived for non-terminal StateList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StateList {
    pub identifier: Box<Identifier>,
    pub state_list_list: Vec<StateListList>,
}

///
/// Type derived for non-terminal StateListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StateListList {
    pub comma: crate::parol_ls_grammar::OwnedToken, /* , */
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct String {
    pub string: crate::parol_ls_grammar::OwnedToken, /* \u{22}(\\.|[^\\])*?\u{22} */
}

///
/// Type derived for non-terminal Symbol
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Symbol {
    NonTerminal(SymbolNonTerminal),
    SimpleToken(SymbolSimpleToken),
    TokenWithStates(SymbolTokenWithStates),
    ScannerSwitch(SymbolScannerSwitch),
}

///
/// Type derived for non-terminal TokenLiteral
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TokenLiteral {
    String(TokenLiteralString),
    LiteralString(TokenLiteralLiteralString),
    Regex(TokenLiteralRegex),
}

///
/// Type derived for non-terminal TokenWithStates
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenWithStates {
    pub l_t: crate::parol_ls_grammar::OwnedToken, /* < */
    pub state_list: Box<StateList>,
    pub g_t: crate::parol_ls_grammar::OwnedToken, /* > */
    pub token_literal: Box<TokenLiteral>,
    pub token_with_states_opt: Option<Box<TokenWithStatesOpt>>,
}

///
/// Type derived for non-terminal TokenWithStatesOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenWithStatesOpt {
    pub a_s_t_control: Box<ASTControl>,
}

///
/// Type derived for non-terminal UserTypeDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UserTypeDeclaration {
    pub colon: crate::parol_ls_grammar::OwnedToken, /* : */
    pub user_type_name: Box<UserTypeName>,
}

///
/// Type derived for non-terminal UserTypeName
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UserTypeName {
    pub identifier: Box<Identifier>,
    pub user_type_name_list: Vec<UserTypeNameList>,
}

///
/// Type derived for non-terminal UserTypeNameList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UserTypeNameList {
    pub double_colon: Box<DoubleColon>,
    pub identifier: Box<Identifier>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    ASTControl(ASTControl),
    Alternation(Alternation),
    AlternationList(Vec<AlternationList>),
    Alternations(Alternations),
    AlternationsList(Vec<AlternationsList>),
    BlockComment(BlockComment),
    Comments(Comments),
    CommentsList(Vec<CommentsList>),
    CommentsListGroup(CommentsListGroup),
    CutOperator(CutOperator),
    Declaration(Declaration),
    DoubleColon(DoubleColon),
    Factor(Factor),
    GrammarDefinition(GrammarDefinition),
    GrammarDefinitionList(Vec<GrammarDefinitionList>),
    Group(Group),
    Identifier(Identifier),
    LineComment(LineComment),
    LiteralString(LiteralString),
    NonTerminal(NonTerminal),
    NonTerminalOpt(Option<Box<NonTerminalOpt>>),
    Optional(Optional),
    ParolLs(ParolLs),
    Production(Production),
    ProductionLHS(ProductionLHS),
    Prolog(Prolog),
    PrologList(Vec<PrologList>),
    PrologList0(Vec<PrologList0>),
    Regex(Regex),
    Repeat(Repeat),
    ScannerDirectives(ScannerDirectives),
    ScannerState(ScannerState),
    ScannerStateList(Vec<ScannerStateList>),
    ScannerSwitch(ScannerSwitch),
    ScannerSwitchOpt(Option<Box<ScannerSwitchOpt>>),
    SimpleToken(SimpleToken),
    SimpleTokenOpt(Option<Box<SimpleTokenOpt>>),
    StartDeclaration(StartDeclaration),
    StateList(StateList),
    StateListList(Vec<StateListList>),
    String(String),
    Symbol(Symbol),
    TokenLiteral(TokenLiteral),
    TokenWithStates(TokenWithStates),
    TokenWithStatesOpt(Option<Box<TokenWithStatesOpt>>),
    UserTypeDeclaration(UserTypeDeclaration),
    UserTypeName(UserTypeName),
    UserTypeNameList(Vec<UserTypeNameList>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ParolLsGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ParolLsGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Just to hold the lifetime generated by parol
    phantom: PhantomData<&'t str>,
}

///
/// The `ParolLsGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ParolLsGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ParolLsGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            phantom: PhantomData::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// ParolLs: Prolog GrammarDefinition;
    ///
    #[parol_runtime::function_name::named]
    fn parol_ls(
        &mut self,
        _prolog: &ParseTreeStackEntry<'t>,
        _grammar_definition: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_definition = pop_item!(self, grammar_definition, GrammarDefinition, context);
        let prolog = pop_item!(self, prolog, Prolog, context);
        let parol_ls_built = ParolLsBuilder::default()
            .prolog(Box::new(prolog))
            .grammar_definition(Box::new(grammar_definition))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parol_ls(&parol_ls_built)?;
        self.push(ASTType::ParolLs(parol_ls_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Prolog: StartDeclaration PrologList /* Vec */ PrologList0 /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn prolog(
        &mut self,
        _start_declaration: &ParseTreeStackEntry<'t>,
        _prolog_list: &ParseTreeStackEntry<'t>,
        _prolog_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prolog_list0 = pop_and_reverse_item!(self, prolog_list0, PrologList0, context);
        let prolog_list = pop_and_reverse_item!(self, prolog_list, PrologList, context);
        let start_declaration = pop_item!(self, start_declaration, StartDeclaration, context);
        let prolog_built = PrologBuilder::default()
            .start_declaration(Box::new(start_declaration))
            .prolog_list(prolog_list)
            .prolog_list0(prolog_list0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.prolog(&prolog_built)?;
        self.push(ASTType::Prolog(prolog_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// PrologList0 /* Vec<T>::Push */: ScannerState PrologList0;
    ///
    #[parol_runtime::function_name::named]
    fn prolog_list0_0(
        &mut self,
        _scanner_state: &ParseTreeStackEntry<'t>,
        _prolog_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut prolog_list0 = pop_item!(self, prolog_list0, PrologList0, context);
        let scanner_state = pop_item!(self, scanner_state, ScannerState, context);
        let prolog_list0_0_built = PrologList0Builder::default()
            .scanner_state(Box::new(scanner_state))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        prolog_list0.push(prolog_list0_0_built);
        self.push(ASTType::PrologList0(prolog_list0), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// PrologList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn prolog_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prolog_list0_1_built = Vec::new();
        self.push(ASTType::PrologList0(prolog_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// PrologList /* Vec<T>::Push */: Declaration PrologList;
    ///
    #[parol_runtime::function_name::named]
    fn prolog_list_0(
        &mut self,
        _declaration: &ParseTreeStackEntry<'t>,
        _prolog_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut prolog_list = pop_item!(self, prolog_list, PrologList, context);
        let declaration = pop_item!(self, declaration, Declaration, context);
        let prolog_list_0_built = PrologListBuilder::default()
            .declaration(Box::new(declaration))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        prolog_list.push(prolog_list_0_built);
        self.push(ASTType::PrologList(prolog_list), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// PrologList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn prolog_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prolog_list_1_built = Vec::new();
        self.push(ASTType::PrologList(prolog_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// StartDeclaration: Comments "%start" : OwnedToken Identifier Comments;
    ///
    #[parol_runtime::function_name::named]
    fn start_declaration(
        &mut self,
        _comments: &ParseTreeStackEntry<'t>,
        percent_start: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _comments0: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_start = percent_start
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments0 = pop_item!(self, comments0, Comments, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let comments = pop_item!(self, comments, Comments, context);
        let start_declaration_built = StartDeclarationBuilder::default()
            .comments(Box::new(comments))
            .percent_start(percent_start)
            .identifier(Box::new(identifier))
            .comments0(Box::new(comments0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .start_declaration(&start_declaration_built)?;
        self.push(ASTType::StartDeclaration(start_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Declaration: "%title" : OwnedToken String Comments;
    ///
    #[parol_runtime::function_name::named]
    fn declaration_0(
        &mut self,
        percent_title: &ParseTreeStackEntry<'t>,
        _string: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_title = percent_title
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let string = pop_item!(self, string, String, context);
        let declaration_0_built = DeclarationPercentTitleStringCommentsBuilder::default()
            .percent_title(percent_title)
            .string(Box::new(string))
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        let declaration_0_built = Declaration::PercentTitleStringComments(declaration_0_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_0_built)?;
        self.push(ASTType::Declaration(declaration_0_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Declaration: "%comment" : OwnedToken String Comments;
    ///
    #[parol_runtime::function_name::named]
    fn declaration_1(
        &mut self,
        percent_comment: &ParseTreeStackEntry<'t>,
        _string: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_comment = percent_comment
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let string = pop_item!(self, string, String, context);
        let declaration_1_built = DeclarationPercentCommentStringCommentsBuilder::default()
            .percent_comment(percent_comment)
            .string(Box::new(string))
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        let declaration_1_built = Declaration::PercentCommentStringComments(declaration_1_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_1_built)?;
        self.push(ASTType::Declaration(declaration_1_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// Declaration: "%user_type" : OwnedToken Identifier "=" : OwnedToken UserTypeName Comments;
    ///
    #[parol_runtime::function_name::named]
    fn declaration_2(
        &mut self,
        percent_user_underscore_type: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        equ: &ParseTreeStackEntry<'t>,
        _user_type_name: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_user_underscore_type = percent_user_underscore_type
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let equ = equ.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let user_type_name = pop_item!(self, user_type_name, UserTypeName, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let declaration_2_built =
            DeclarationPercentUserUnderscoreTypeIdentifierEquUserTypeNameCommentsBuilder::default()
                .percent_user_underscore_type(percent_user_underscore_type)
                .identifier(Box::new(identifier))
                .equ(equ)
                .user_type_name(Box::new(user_type_name))
                .comments(Box::new(comments))
                .build()
                .into_diagnostic()?;
        let declaration_2_built =
            Declaration::PercentUserUnderscoreTypeIdentifierEquUserTypeNameComments(
                declaration_2_built,
            );
        // Calling user action here
        self.user_grammar.declaration(&declaration_2_built)?;
        self.push(ASTType::Declaration(declaration_2_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// Declaration: ScannerDirectives;
    ///
    #[parol_runtime::function_name::named]
    fn declaration_3(
        &mut self,
        _scanner_directives: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_directives = pop_item!(self, scanner_directives, ScannerDirectives, context);
        let declaration_3_built = DeclarationScannerDirectivesBuilder::default()
            .scanner_directives(Box::new(scanner_directives))
            .build()
            .into_diagnostic()?;
        let declaration_3_built = Declaration::ScannerDirectives(declaration_3_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_3_built)?;
        self.push(ASTType::Declaration(declaration_3_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// ScannerDirectives: "%line_comment" : OwnedToken TokenLiteral Comments;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_directives_0(
        &mut self,
        percent_line_underscore_comment: &ParseTreeStackEntry<'t>,
        _token_literal: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_line_underscore_comment = percent_line_underscore_comment
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let token_literal = pop_item!(self, token_literal, TokenLiteral, context);
        let scanner_directives_0_built =
            ScannerDirectivesPercentLineUnderscoreCommentTokenLiteralCommentsBuilder::default()
                .percent_line_underscore_comment(percent_line_underscore_comment)
                .token_literal(Box::new(token_literal))
                .comments(Box::new(comments))
                .build()
                .into_diagnostic()?;
        let scanner_directives_0_built =
            ScannerDirectives::PercentLineUnderscoreCommentTokenLiteralComments(
                scanner_directives_0_built,
            );
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_0_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// ScannerDirectives: "%block_comment" : OwnedToken TokenLiteral TokenLiteral Comments;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_directives_1(
        &mut self,
        percent_block_underscore_comment: &ParseTreeStackEntry<'t>,
        _token_literal: &ParseTreeStackEntry<'t>,
        _token_literal0: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_block_underscore_comment = percent_block_underscore_comment
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let token_literal0 = pop_item!(self, token_literal0, TokenLiteral, context);
        let token_literal = pop_item!(self, token_literal, TokenLiteral, context);
        let scanner_directives_1_built = ScannerDirectivesPercentBlockUnderscoreCommentTokenLiteralTokenLiteralCommentsBuilder::default()
            .percent_block_underscore_comment(percent_block_underscore_comment)
            .token_literal(Box::new(token_literal))
            .token_literal0(Box::new(token_literal0))
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        let scanner_directives_1_built =
            ScannerDirectives::PercentBlockUnderscoreCommentTokenLiteralTokenLiteralComments(
                scanner_directives_1_built,
            );
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_1_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// ScannerDirectives: "%auto_newline_off" : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_directives_2(
        &mut self,
        percent_auto_underscore_newline_underscore_off: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_auto_underscore_newline_underscore_off =
            percent_auto_underscore_newline_underscore_off
                .token(parse_tree)?
                .try_into()
                .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let scanner_directives_2_built =
            ScannerDirectivesPercentAutoUnderscoreNewlineUnderscoreOffCommentsBuilder::default()
                .percent_auto_underscore_newline_underscore_off(
                    percent_auto_underscore_newline_underscore_off,
                )
                .comments(Box::new(comments))
                .build()
                .into_diagnostic()?;
        let scanner_directives_2_built =
            ScannerDirectives::PercentAutoUnderscoreNewlineUnderscoreOffComments(
                scanner_directives_2_built,
            );
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_2_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// ScannerDirectives: "%auto_ws_off" : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_directives_3(
        &mut self,
        percent_auto_underscore_ws_underscore_off: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_auto_underscore_ws_underscore_off = percent_auto_underscore_ws_underscore_off
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let scanner_directives_3_built =
            ScannerDirectivesPercentAutoUnderscoreWsUnderscoreOffCommentsBuilder::default()
                .percent_auto_underscore_ws_underscore_off(
                    percent_auto_underscore_ws_underscore_off,
                )
                .comments(Box::new(comments))
                .build()
                .into_diagnostic()?;
        let scanner_directives_3_built =
            ScannerDirectives::PercentAutoUnderscoreWsUnderscoreOffComments(
                scanner_directives_3_built,
            );
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_3_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// GrammarDefinition: "%%" : OwnedToken Production GrammarDefinitionList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn grammar_definition(
        &mut self,
        percent_percent: &ParseTreeStackEntry<'t>,
        _production: &ParseTreeStackEntry<'t>,
        _grammar_definition_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_percent = percent_percent
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let grammar_definition_list = pop_and_reverse_item!(
            self,
            grammar_definition_list,
            GrammarDefinitionList,
            context
        );
        let production = pop_item!(self, production, Production, context);
        let grammar_definition_built = GrammarDefinitionBuilder::default()
            .percent_percent(percent_percent)
            .production(Box::new(production))
            .grammar_definition_list(grammar_definition_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .grammar_definition(&grammar_definition_built)?;
        self.push(
            ASTType::GrammarDefinition(grammar_definition_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// GrammarDefinitionList /* Vec<T>::Push */: Production GrammarDefinitionList;
    ///
    #[parol_runtime::function_name::named]
    fn grammar_definition_list_0(
        &mut self,
        _production: &ParseTreeStackEntry<'t>,
        _grammar_definition_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut grammar_definition_list = pop_item!(
            self,
            grammar_definition_list,
            GrammarDefinitionList,
            context
        );
        let production = pop_item!(self, production, Production, context);
        let grammar_definition_list_0_built = GrammarDefinitionListBuilder::default()
            .production(Box::new(production))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        grammar_definition_list.push(grammar_definition_list_0_built);
        self.push(
            ASTType::GrammarDefinitionList(grammar_definition_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// GrammarDefinitionList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn grammar_definition_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_definition_list_1_built = Vec::new();
        self.push(
            ASTType::GrammarDefinitionList(grammar_definition_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// DoubleColon: "::" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn double_colon(
        &mut self,
        double_colon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let double_colon = double_colon
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let double_colon_built = DoubleColonBuilder::default()
            .double_colon(double_colon)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.double_colon(&double_colon_built)?;
        self.push(ASTType::DoubleColon(double_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// ProductionLHS: Comments Identifier Comments ":" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn production_l_h_s(
        &mut self,
        _comments: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _comments0: &ParseTreeStackEntry<'t>,
        colon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = colon.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments0 = pop_item!(self, comments0, Comments, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let comments = pop_item!(self, comments, Comments, context);
        let production_l_h_s_built = ProductionLHSBuilder::default()
            .comments(Box::new(comments))
            .identifier(Box::new(identifier))
            .comments0(Box::new(comments0))
            .colon(colon)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .production_l_h_s(&production_l_h_s_built)?;
        self.push(ASTType::ProductionLHS(production_l_h_s_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Production: ProductionLHS Alternations ";" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn production(
        &mut self,
        _production_l_h_s: &ParseTreeStackEntry<'t>,
        _alternations: &ParseTreeStackEntry<'t>,
        semicolon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = semicolon.token(parse_tree)?.try_into().into_diagnostic()?;
        let alternations = pop_item!(self, alternations, Alternations, context);
        let production_l_h_s = pop_item!(self, production_l_h_s, ProductionLHS, context);
        let production_built = ProductionBuilder::default()
            .production_l_h_s(Box::new(production_l_h_s))
            .alternations(Box::new(alternations))
            .semicolon(semicolon)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.production(&production_built)?;
        self.push(ASTType::Production(production_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// Alternations: Alternation AlternationsList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn alternations(
        &mut self,
        _alternation: &ParseTreeStackEntry<'t>,
        _alternations_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations_list =
            pop_and_reverse_item!(self, alternations_list, AlternationsList, context);
        let alternation = pop_item!(self, alternation, Alternation, context);
        let alternations_built = AlternationsBuilder::default()
            .alternation(Box::new(alternation))
            .alternations_list(alternations_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.alternations(&alternations_built)?;
        self.push(ASTType::Alternations(alternations_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// AlternationsList /* Vec<T>::Push */: "\|" : OwnedToken Comments Alternation AlternationsList;
    ///
    #[parol_runtime::function_name::named]
    fn alternations_list_0(
        &mut self,
        or: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _alternation: &ParseTreeStackEntry<'t>,
        _alternations_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = or.token(parse_tree)?.try_into().into_diagnostic()?;
        let mut alternations_list = pop_item!(self, alternations_list, AlternationsList, context);
        let alternation = pop_item!(self, alternation, Alternation, context);
        let comments = pop_item!(self, comments, Comments, context);
        let alternations_list_0_built = AlternationsListBuilder::default()
            .alternation(Box::new(alternation))
            .comments(Box::new(comments))
            .or(or)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        alternations_list.push(alternations_list_0_built);
        self.push(ASTType::AlternationsList(alternations_list), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// AlternationsList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn alternations_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations_list_1_built = Vec::new();
        self.push(
            ASTType::AlternationsList(alternations_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Alternation: AlternationList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn alternation(
        &mut self,
        _alternation_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternation_list =
            pop_and_reverse_item!(self, alternation_list, AlternationList, context);
        let alternation_built = AlternationBuilder::default()
            .alternation_list(alternation_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.alternation(&alternation_built)?;
        self.push(ASTType::Alternation(alternation_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// AlternationList /* Vec<T>::Push */: Factor Comments AlternationList;
    ///
    #[parol_runtime::function_name::named]
    fn alternation_list_0(
        &mut self,
        _factor: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _alternation_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut alternation_list = pop_item!(self, alternation_list, AlternationList, context);
        let comments = pop_item!(self, comments, Comments, context);
        let factor = pop_item!(self, factor, Factor, context);
        let alternation_list_0_built = AlternationListBuilder::default()
            .comments(Box::new(comments))
            .factor(Box::new(factor))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        alternation_list.push(alternation_list_0_built);
        self.push(ASTType::AlternationList(alternation_list), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// AlternationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn alternation_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternation_list_1_built = Vec::new();
        self.push(ASTType::AlternationList(alternation_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// Factor: Group;
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(
        &mut self,
        _group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let group = pop_item!(self, group, Group, context);
        let factor_0_built = FactorGroupBuilder::default()
            .group(Box::new(group))
            .build()
            .into_diagnostic()?;
        let factor_0_built = Factor::Group(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// Factor: Repeat;
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(
        &mut self,
        _repeat: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let repeat = pop_item!(self, repeat, Repeat, context);
        let factor_1_built = FactorRepeatBuilder::default()
            .repeat(Box::new(repeat))
            .build()
            .into_diagnostic()?;
        let factor_1_built = Factor::Repeat(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// Factor: Optional;
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(
        &mut self,
        _optional: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let optional = pop_item!(self, optional, Optional, context);
        let factor_2_built = FactorOptionalBuilder::default()
            .optional(Box::new(optional))
            .build()
            .into_diagnostic()?;
        let factor_2_built = Factor::Optional(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// Factor: Symbol;
    ///
    #[parol_runtime::function_name::named]
    fn factor_3(
        &mut self,
        _symbol: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let symbol = pop_item!(self, symbol, Symbol, context);
        let factor_3_built = FactorSymbolBuilder::default()
            .symbol(Box::new(symbol))
            .build()
            .into_diagnostic()?;
        let factor_3_built = Factor::Symbol(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// Symbol: NonTerminal;
    ///
    #[parol_runtime::function_name::named]
    fn symbol_0(
        &mut self,
        _non_terminal: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_terminal = pop_item!(self, non_terminal, NonTerminal, context);
        let symbol_0_built = SymbolNonTerminalBuilder::default()
            .non_terminal(Box::new(non_terminal))
            .build()
            .into_diagnostic()?;
        let symbol_0_built = Symbol::NonTerminal(symbol_0_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_0_built)?;
        self.push(ASTType::Symbol(symbol_0_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// Symbol: SimpleToken;
    ///
    #[parol_runtime::function_name::named]
    fn symbol_1(
        &mut self,
        _simple_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_token = pop_item!(self, simple_token, SimpleToken, context);
        let symbol_1_built = SymbolSimpleTokenBuilder::default()
            .simple_token(Box::new(simple_token))
            .build()
            .into_diagnostic()?;
        let symbol_1_built = Symbol::SimpleToken(symbol_1_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_1_built)?;
        self.push(ASTType::Symbol(symbol_1_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// Symbol: TokenWithStates;
    ///
    #[parol_runtime::function_name::named]
    fn symbol_2(
        &mut self,
        _token_with_states: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_with_states = pop_item!(self, token_with_states, TokenWithStates, context);
        let symbol_2_built = SymbolTokenWithStatesBuilder::default()
            .token_with_states(Box::new(token_with_states))
            .build()
            .into_diagnostic()?;
        let symbol_2_built = Symbol::TokenWithStates(symbol_2_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_2_built)?;
        self.push(ASTType::Symbol(symbol_2_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// Symbol: ScannerSwitch;
    ///
    #[parol_runtime::function_name::named]
    fn symbol_3(
        &mut self,
        _scanner_switch: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_switch = pop_item!(self, scanner_switch, ScannerSwitch, context);
        let symbol_3_built = SymbolScannerSwitchBuilder::default()
            .scanner_switch(Box::new(scanner_switch))
            .build()
            .into_diagnostic()?;
        let symbol_3_built = Symbol::ScannerSwitch(symbol_3_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_3_built)?;
        self.push(ASTType::Symbol(symbol_3_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// TokenLiteral: String;
    ///
    #[parol_runtime::function_name::named]
    fn token_literal_0(
        &mut self,
        _string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let token_literal_0_built = TokenLiteralStringBuilder::default()
            .string(Box::new(string))
            .build()
            .into_diagnostic()?;
        let token_literal_0_built = TokenLiteral::String(token_literal_0_built);
        // Calling user action here
        self.user_grammar.token_literal(&token_literal_0_built)?;
        self.push(ASTType::TokenLiteral(token_literal_0_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// TokenLiteral: LiteralString;
    ///
    #[parol_runtime::function_name::named]
    fn token_literal_1(
        &mut self,
        _literal_string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_string = pop_item!(self, literal_string, LiteralString, context);
        let token_literal_1_built = TokenLiteralLiteralStringBuilder::default()
            .literal_string(Box::new(literal_string))
            .build()
            .into_diagnostic()?;
        let token_literal_1_built = TokenLiteral::LiteralString(token_literal_1_built);
        // Calling user action here
        self.user_grammar.token_literal(&token_literal_1_built)?;
        self.push(ASTType::TokenLiteral(token_literal_1_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// TokenLiteral: Regex;
    ///
    #[parol_runtime::function_name::named]
    fn token_literal_2(
        &mut self,
        _regex: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let regex = pop_item!(self, regex, Regex, context);
        let token_literal_2_built = TokenLiteralRegexBuilder::default()
            .regex(Box::new(regex))
            .build()
            .into_diagnostic()?;
        let token_literal_2_built = TokenLiteral::Regex(token_literal_2_built);
        // Calling user action here
        self.user_grammar.token_literal(&token_literal_2_built)?;
        self.push(ASTType::TokenLiteral(token_literal_2_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// SimpleToken: TokenLiteral SimpleTokenOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn simple_token(
        &mut self,
        _token_literal: &ParseTreeStackEntry<'t>,
        _simple_token_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_token_opt = pop_item!(self, simple_token_opt, SimpleTokenOpt, context);
        let token_literal = pop_item!(self, token_literal, TokenLiteral, context);
        let simple_token_built = SimpleTokenBuilder::default()
            .token_literal(Box::new(token_literal))
            .simple_token_opt(simple_token_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.simple_token(&simple_token_built)?;
        self.push(ASTType::SimpleToken(simple_token_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// SimpleTokenOpt /* Option<T>::Some */: ASTControl;
    ///
    #[parol_runtime::function_name::named]
    fn simple_token_opt_0(
        &mut self,
        _a_s_t_control: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a_s_t_control = pop_item!(self, a_s_t_control, ASTControl, context);
        let simple_token_opt_0_built = SimpleTokenOptBuilder::default()
            .a_s_t_control(Box::new(a_s_t_control))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::SimpleTokenOpt(Some(Box::new(simple_token_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// SimpleTokenOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn simple_token_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleTokenOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// TokenWithStates: "<" : OwnedToken StateList ">" : OwnedToken TokenLiteral TokenWithStatesOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn token_with_states(
        &mut self,
        l_t: &ParseTreeStackEntry<'t>,
        _state_list: &ParseTreeStackEntry<'t>,
        g_t: &ParseTreeStackEntry<'t>,
        _token_literal: &ParseTreeStackEntry<'t>,
        _token_with_states_opt: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t = l_t.token(parse_tree)?.try_into().into_diagnostic()?;
        let g_t = g_t.token(parse_tree)?.try_into().into_diagnostic()?;
        let token_with_states_opt =
            pop_item!(self, token_with_states_opt, TokenWithStatesOpt, context);
        let token_literal = pop_item!(self, token_literal, TokenLiteral, context);
        let state_list = pop_item!(self, state_list, StateList, context);
        let token_with_states_built = TokenWithStatesBuilder::default()
            .l_t(l_t)
            .state_list(Box::new(state_list))
            .g_t(g_t)
            .token_literal(Box::new(token_literal))
            .token_with_states_opt(token_with_states_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .token_with_states(&token_with_states_built)?;
        self.push(ASTType::TokenWithStates(token_with_states_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// TokenWithStatesOpt /* Option<T>::Some */: ASTControl;
    ///
    #[parol_runtime::function_name::named]
    fn token_with_states_opt_0(
        &mut self,
        _a_s_t_control: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a_s_t_control = pop_item!(self, a_s_t_control, ASTControl, context);
        let token_with_states_opt_0_built = TokenWithStatesOptBuilder::default()
            .a_s_t_control(Box::new(a_s_t_control))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::TokenWithStatesOpt(Some(Box::new(token_with_states_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// TokenWithStatesOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn token_with_states_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TokenWithStatesOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// Group: "\(" : OwnedToken Alternations "\)" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn group(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        _alternations: &ParseTreeStackEntry<'t>,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let r_paren = r_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let alternations = pop_item!(self, alternations, Alternations, context);
        let group_built = GroupBuilder::default()
            .l_paren(l_paren)
            .alternations(Box::new(alternations))
            .r_paren(r_paren)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.group(&group_built)?;
        self.push(ASTType::Group(group_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// Optional: "\[" : OwnedToken Alternations "\]" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn optional(
        &mut self,
        l_bracket: &ParseTreeStackEntry<'t>,
        _alternations: &ParseTreeStackEntry<'t>,
        r_bracket: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket = l_bracket.token(parse_tree)?.try_into().into_diagnostic()?;
        let r_bracket = r_bracket.token(parse_tree)?.try_into().into_diagnostic()?;
        let alternations = pop_item!(self, alternations, Alternations, context);
        let optional_built = OptionalBuilder::default()
            .l_bracket(l_bracket)
            .alternations(Box::new(alternations))
            .r_bracket(r_bracket)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.optional(&optional_built)?;
        self.push(ASTType::Optional(optional_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// Repeat: "\{" : OwnedToken Alternations "\}" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn repeat(
        &mut self,
        l_brace: &ParseTreeStackEntry<'t>,
        _alternations: &ParseTreeStackEntry<'t>,
        r_brace: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace = l_brace.token(parse_tree)?.try_into().into_diagnostic()?;
        let r_brace = r_brace.token(parse_tree)?.try_into().into_diagnostic()?;
        let alternations = pop_item!(self, alternations, Alternations, context);
        let repeat_built = RepeatBuilder::default()
            .l_brace(l_brace)
            .alternations(Box::new(alternations))
            .r_brace(r_brace)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.repeat(&repeat_built)?;
        self.push(ASTType::Repeat(repeat_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// NonTerminal: Identifier NonTerminalOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn non_terminal(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _non_terminal_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_terminal_opt = pop_item!(self, non_terminal_opt, NonTerminalOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let non_terminal_built = NonTerminalBuilder::default()
            .identifier(Box::new(identifier))
            .non_terminal_opt(non_terminal_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.non_terminal(&non_terminal_built)?;
        self.push(ASTType::NonTerminal(non_terminal_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// NonTerminalOpt /* Option<T>::Some */: ASTControl;
    ///
    #[parol_runtime::function_name::named]
    fn non_terminal_opt_0(
        &mut self,
        _a_s_t_control: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a_s_t_control = pop_item!(self, a_s_t_control, ASTControl, context);
        let non_terminal_opt_0_built = NonTerminalOptBuilder::default()
            .a_s_t_control(Box::new(a_s_t_control))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::NonTerminalOpt(Some(Box::new(non_terminal_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// NonTerminalOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn non_terminal_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::NonTerminalOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// Identifier: "[a-zA-Z_][a-zA-Z0-9_]*" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn identifier(
        &mut self,
        identifier: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = identifier.token(parse_tree)?.try_into().into_diagnostic()?;
        let identifier_built = IdentifierBuilder::default()
            .identifier(identifier)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.identifier(&identifier_built)?;
        self.push(ASTType::Identifier(identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// String: "\u{22}(\\.|[^\\])*?\u{22}" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn string(
        &mut self,
        string: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = string.token(parse_tree)?.try_into().into_diagnostic()?;
        let string_built = StringBuilder::default()
            .string(string)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// LiteralString: "'(\\'|[^'])*?'" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn literal_string(
        &mut self,
        literal_string: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_string = literal_string
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let literal_string_built = LiteralStringBuilder::default()
            .literal_string(literal_string)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.literal_string(&literal_string_built)?;
        self.push(ASTType::LiteralString(literal_string_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// ScannerState: "%scanner" : OwnedToken Identifier "\{" : OwnedToken ScannerStateList /* Vec */ "\}" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_state(
        &mut self,
        percent_scanner: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        l_brace: &ParseTreeStackEntry<'t>,
        _scanner_state_list: &ParseTreeStackEntry<'t>,
        r_brace: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_scanner = percent_scanner
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let l_brace = l_brace.token(parse_tree)?.try_into().into_diagnostic()?;
        let r_brace = r_brace.token(parse_tree)?.try_into().into_diagnostic()?;
        let scanner_state_list =
            pop_and_reverse_item!(self, scanner_state_list, ScannerStateList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let scanner_state_built = ScannerStateBuilder::default()
            .percent_scanner(percent_scanner)
            .identifier(Box::new(identifier))
            .l_brace(l_brace)
            .scanner_state_list(scanner_state_list)
            .r_brace(r_brace)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.scanner_state(&scanner_state_built)?;
        self.push(ASTType::ScannerState(scanner_state_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// ScannerStateList /* Vec<T>::Push */: ScannerDirectives ScannerStateList;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_state_list_0(
        &mut self,
        _scanner_directives: &ParseTreeStackEntry<'t>,
        _scanner_state_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scanner_state_list = pop_item!(self, scanner_state_list, ScannerStateList, context);
        let scanner_directives = pop_item!(self, scanner_directives, ScannerDirectives, context);
        let scanner_state_list_0_built = ScannerStateListBuilder::default()
            .scanner_directives(Box::new(scanner_directives))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        scanner_state_list.push(scanner_state_list_0_built);
        self.push(ASTType::ScannerStateList(scanner_state_list), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// ScannerStateList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_state_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_state_list_1_built = Vec::new();
        self.push(
            ASTType::ScannerStateList(scanner_state_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// StateList: Identifier StateListList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn state_list(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _state_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let state_list_list = pop_and_reverse_item!(self, state_list_list, StateListList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let state_list_built = StateListBuilder::default()
            .identifier(Box::new(identifier))
            .state_list_list(state_list_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.state_list(&state_list_built)?;
        self.push(ASTType::StateList(state_list_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// StateListList /* Vec<T>::Push */: "," : OwnedToken Identifier StateListList;
    ///
    #[parol_runtime::function_name::named]
    fn state_list_list_0(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _state_list_list: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token(parse_tree)?.try_into().into_diagnostic()?;
        let mut state_list_list = pop_item!(self, state_list_list, StateListList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let state_list_list_0_built = StateListListBuilder::default()
            .identifier(Box::new(identifier))
            .comma(comma)
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        state_list_list.push(state_list_list_0_built);
        self.push(ASTType::StateListList(state_list_list), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// StateListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn state_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let state_list_list_1_built = Vec::new();
        self.push(ASTType::StateListList(state_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// ScannerSwitch: "%sc" : OwnedToken "\(" : OwnedToken ScannerSwitchOpt /* Option */ "\)" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_switch_0(
        &mut self,
        percent_sc: &ParseTreeStackEntry<'t>,
        l_paren: &ParseTreeStackEntry<'t>,
        _scanner_switch_opt: &ParseTreeStackEntry<'t>,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_sc = percent_sc.token(parse_tree)?.try_into().into_diagnostic()?;
        let l_paren = l_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let r_paren = r_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let scanner_switch_opt = pop_item!(self, scanner_switch_opt, ScannerSwitchOpt, context);
        let scanner_switch_0_built =
            ScannerSwitchPercentScLParenScannerSwitchOptRParenBuilder::default()
                .percent_sc(percent_sc)
                .l_paren(l_paren)
                .scanner_switch_opt(scanner_switch_opt)
                .r_paren(r_paren)
                .build()
                .into_diagnostic()?;
        let scanner_switch_0_built =
            ScannerSwitch::PercentScLParenScannerSwitchOptRParen(scanner_switch_0_built);
        // Calling user action here
        self.user_grammar.scanner_switch(&scanner_switch_0_built)?;
        self.push(ASTType::ScannerSwitch(scanner_switch_0_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// ScannerSwitch: "%push" : OwnedToken "\(" : OwnedToken Identifier "\)" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_switch_1(
        &mut self,
        percent_push: &ParseTreeStackEntry<'t>,
        l_paren: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_push = percent_push
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let l_paren = l_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let r_paren = r_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let identifier = pop_item!(self, identifier, Identifier, context);
        let scanner_switch_1_built =
            ScannerSwitchPercentPushLParenIdentifierRParenBuilder::default()
                .percent_push(percent_push)
                .l_paren(l_paren)
                .identifier(Box::new(identifier))
                .r_paren(r_paren)
                .build()
                .into_diagnostic()?;
        let scanner_switch_1_built =
            ScannerSwitch::PercentPushLParenIdentifierRParen(scanner_switch_1_built);
        // Calling user action here
        self.user_grammar.scanner_switch(&scanner_switch_1_built)?;
        self.push(ASTType::ScannerSwitch(scanner_switch_1_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// ScannerSwitch: "%pop" : OwnedToken "\(" : OwnedToken "\)" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_switch_2(
        &mut self,
        percent_pop: &ParseTreeStackEntry<'t>,
        l_paren: &ParseTreeStackEntry<'t>,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_pop = percent_pop
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let l_paren = l_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let r_paren = r_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let scanner_switch_2_built = ScannerSwitchPercentPopLParenRParenBuilder::default()
            .percent_pop(percent_pop)
            .l_paren(l_paren)
            .r_paren(r_paren)
            .build()
            .into_diagnostic()?;
        let scanner_switch_2_built = ScannerSwitch::PercentPopLParenRParen(scanner_switch_2_built);
        // Calling user action here
        self.user_grammar.scanner_switch(&scanner_switch_2_built)?;
        self.push(ASTType::ScannerSwitch(scanner_switch_2_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// ScannerSwitchOpt /* Option<T>::Some */: Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_switch_opt_0(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let scanner_switch_opt_0_built = ScannerSwitchOptBuilder::default()
            .identifier(Box::new(identifier))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ScannerSwitchOpt(Some(Box::new(scanner_switch_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// ScannerSwitchOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn scanner_switch_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ScannerSwitchOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// ASTControl: CutOperator;
    ///
    #[parol_runtime::function_name::named]
    fn a_s_t_control_0(
        &mut self,
        _cut_operator: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cut_operator = pop_item!(self, cut_operator, CutOperator, context);
        let a_s_t_control_0_built = ASTControlCutOperatorBuilder::default()
            .cut_operator(Box::new(cut_operator))
            .build()
            .into_diagnostic()?;
        let a_s_t_control_0_built = ASTControl::CutOperator(a_s_t_control_0_built);
        // Calling user action here
        self.user_grammar.a_s_t_control(&a_s_t_control_0_built)?;
        self.push(ASTType::ASTControl(a_s_t_control_0_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// ASTControl: UserTypeDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn a_s_t_control_1(
        &mut self,
        _user_type_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_declaration =
            pop_item!(self, user_type_declaration, UserTypeDeclaration, context);
        let a_s_t_control_1_built = ASTControlUserTypeDeclarationBuilder::default()
            .user_type_declaration(Box::new(user_type_declaration))
            .build()
            .into_diagnostic()?;
        let a_s_t_control_1_built = ASTControl::UserTypeDeclaration(a_s_t_control_1_built);
        // Calling user action here
        self.user_grammar.a_s_t_control(&a_s_t_control_1_built)?;
        self.push(ASTType::ASTControl(a_s_t_control_1_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// CutOperator: "\^" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn cut_operator(
        &mut self,
        cut_operator: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cut_operator = cut_operator
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let cut_operator_built = CutOperatorBuilder::default()
            .cut_operator(cut_operator)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.cut_operator(&cut_operator_built)?;
        self.push(ASTType::CutOperator(cut_operator_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// UserTypeDeclaration: ":" : OwnedToken UserTypeName;
    ///
    #[parol_runtime::function_name::named]
    fn user_type_declaration(
        &mut self,
        colon: &ParseTreeStackEntry<'t>,
        _user_type_name: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = colon.token(parse_tree)?.try_into().into_diagnostic()?;
        let user_type_name = pop_item!(self, user_type_name, UserTypeName, context);
        let user_type_declaration_built = UserTypeDeclarationBuilder::default()
            .colon(colon)
            .user_type_name(Box::new(user_type_name))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .user_type_declaration(&user_type_declaration_built)?;
        self.push(
            ASTType::UserTypeDeclaration(user_type_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// UserTypeName: Identifier UserTypeNameList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn user_type_name(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _user_type_name_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_name_list =
            pop_and_reverse_item!(self, user_type_name_list, UserTypeNameList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let user_type_name_built = UserTypeNameBuilder::default()
            .identifier(Box::new(identifier))
            .user_type_name_list(user_type_name_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.user_type_name(&user_type_name_built)?;
        self.push(ASTType::UserTypeName(user_type_name_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// UserTypeNameList /* Vec<T>::Push */: DoubleColon Identifier UserTypeNameList;
    ///
    #[parol_runtime::function_name::named]
    fn user_type_name_list_0(
        &mut self,
        _double_colon: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _user_type_name_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut user_type_name_list =
            pop_item!(self, user_type_name_list, UserTypeNameList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let double_colon = pop_item!(self, double_colon, DoubleColon, context);
        let user_type_name_list_0_built = UserTypeNameListBuilder::default()
            .identifier(Box::new(identifier))
            .double_colon(Box::new(double_colon))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        user_type_name_list.push(user_type_name_list_0_built);
        self.push(ASTType::UserTypeNameList(user_type_name_list), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// UserTypeNameList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn user_type_name_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_name_list_1_built = Vec::new();
        self.push(
            ASTType::UserTypeNameList(user_type_name_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// Comments: CommentsList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn comments(
        &mut self,
        _comments_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_list = pop_and_reverse_item!(self, comments_list, CommentsList, context);
        let comments_built = CommentsBuilder::default()
            .comments_list(comments_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comments(&comments_built)?;
        self.push(ASTType::Comments(comments_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// CommentsList /* Vec<T>::Push */: CommentsListGroup CommentsList;
    ///
    #[parol_runtime::function_name::named]
    fn comments_list_0(
        &mut self,
        _comments_list_group: &ParseTreeStackEntry<'t>,
        _comments_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut comments_list = pop_item!(self, comments_list, CommentsList, context);
        let comments_list_group = pop_item!(self, comments_list_group, CommentsListGroup, context);
        let comments_list_0_built = CommentsListBuilder::default()
            .comments_list_group(Box::new(comments_list_group))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        comments_list.push(comments_list_0_built);
        self.push(ASTType::CommentsList(comments_list), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// CommentsListGroup: LineComment;
    ///
    #[parol_runtime::function_name::named]
    fn comments_list_group_0(
        &mut self,
        _line_comment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_comment = pop_item!(self, line_comment, LineComment, context);
        let comments_list_group_0_built = CommentsListGroupLineCommentBuilder::default()
            .line_comment(Box::new(line_comment))
            .build()
            .into_diagnostic()?;
        let comments_list_group_0_built =
            CommentsListGroup::LineComment(comments_list_group_0_built);
        self.push(
            ASTType::CommentsListGroup(comments_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// CommentsListGroup: BlockComment;
    ///
    #[parol_runtime::function_name::named]
    fn comments_list_group_1(
        &mut self,
        _block_comment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block_comment = pop_item!(self, block_comment, BlockComment, context);
        let comments_list_group_1_built = CommentsListGroupBlockCommentBuilder::default()
            .block_comment(Box::new(block_comment))
            .build()
            .into_diagnostic()?;
        let comments_list_group_1_built =
            CommentsListGroup::BlockComment(comments_list_group_1_built);
        self.push(
            ASTType::CommentsListGroup(comments_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// CommentsList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn comments_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_list_1_built = Vec::new();
        self.push(ASTType::CommentsList(comments_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// LineComment: "//.*(:?\r\n|\r|\n|$)" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn line_comment(
        &mut self,
        line_comment: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_comment = line_comment
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let line_comment_built = LineCommentBuilder::default()
            .line_comment(line_comment)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line_comment(&line_comment_built)?;
        self.push(ASTType::LineComment(line_comment_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// BlockComment: "(?ms)/\u{2a}.*?\u{2a}/" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn block_comment(
        &mut self,
        block_comment: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block_comment = block_comment
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let block_comment_built = BlockCommentBuilder::default()
            .block_comment(block_comment)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.block_comment(&block_comment_built)?;
        self.push(ASTType::BlockComment(block_comment_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// Regex: "/(\\/|[^/]|)*?/" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn regex(
        &mut self,
        regex: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let regex = regex.token(parse_tree)?.try_into().into_diagnostic()?;
        let regex_built = RegexBuilder::default()
            .regex(regex)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.regex(&regex_built)?;
        self.push(ASTType::Regex(regex_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ParolLsGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item ParolLsGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.parol_ls(&children[0], &children[1], parse_tree),
            1 => self.prolog(&children[0], &children[1], &children[2], parse_tree),
            2 => self.prolog_list0_0(&children[0], &children[1], parse_tree),
            3 => self.prolog_list0_1(parse_tree),
            4 => self.prolog_list_0(&children[0], &children[1], parse_tree),
            5 => self.prolog_list_1(parse_tree),
            6 => self.start_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            7 => self.declaration_0(&children[0], &children[1], &children[2], parse_tree),
            8 => self.declaration_1(&children[0], &children[1], &children[2], parse_tree),
            9 => self.declaration_2(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            10 => self.declaration_3(&children[0], parse_tree),
            11 => self.scanner_directives_0(&children[0], &children[1], &children[2], parse_tree),
            12 => self.scanner_directives_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            13 => self.scanner_directives_2(&children[0], &children[1], parse_tree),
            14 => self.scanner_directives_3(&children[0], &children[1], parse_tree),
            15 => self.grammar_definition(&children[0], &children[1], &children[2], parse_tree),
            16 => self.grammar_definition_list_0(&children[0], &children[1], parse_tree),
            17 => self.grammar_definition_list_1(parse_tree),
            18 => self.double_colon(&children[0], parse_tree),
            19 => self.production_l_h_s(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            20 => self.production(&children[0], &children[1], &children[2], parse_tree),
            21 => self.alternations(&children[0], &children[1], parse_tree),
            22 => self.alternations_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            23 => self.alternations_list_1(parse_tree),
            24 => self.alternation(&children[0], parse_tree),
            25 => self.alternation_list_0(&children[0], &children[1], &children[2], parse_tree),
            26 => self.alternation_list_1(parse_tree),
            27 => self.factor_0(&children[0], parse_tree),
            28 => self.factor_1(&children[0], parse_tree),
            29 => self.factor_2(&children[0], parse_tree),
            30 => self.factor_3(&children[0], parse_tree),
            31 => self.symbol_0(&children[0], parse_tree),
            32 => self.symbol_1(&children[0], parse_tree),
            33 => self.symbol_2(&children[0], parse_tree),
            34 => self.symbol_3(&children[0], parse_tree),
            35 => self.token_literal_0(&children[0], parse_tree),
            36 => self.token_literal_1(&children[0], parse_tree),
            37 => self.token_literal_2(&children[0], parse_tree),
            38 => self.simple_token(&children[0], &children[1], parse_tree),
            39 => self.simple_token_opt_0(&children[0], parse_tree),
            40 => self.simple_token_opt_1(parse_tree),
            41 => self.token_with_states(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            42 => self.token_with_states_opt_0(&children[0], parse_tree),
            43 => self.token_with_states_opt_1(parse_tree),
            44 => self.group(&children[0], &children[1], &children[2], parse_tree),
            45 => self.optional(&children[0], &children[1], &children[2], parse_tree),
            46 => self.repeat(&children[0], &children[1], &children[2], parse_tree),
            47 => self.non_terminal(&children[0], &children[1], parse_tree),
            48 => self.non_terminal_opt_0(&children[0], parse_tree),
            49 => self.non_terminal_opt_1(parse_tree),
            50 => self.identifier(&children[0], parse_tree),
            51 => self.string(&children[0], parse_tree),
            52 => self.literal_string(&children[0], parse_tree),
            53 => self.scanner_state(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            54 => self.scanner_state_list_0(&children[0], &children[1], parse_tree),
            55 => self.scanner_state_list_1(parse_tree),
            56 => self.state_list(&children[0], &children[1], parse_tree),
            57 => self.state_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            58 => self.state_list_list_1(parse_tree),
            59 => self.scanner_switch_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            60 => self.scanner_switch_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            61 => self.scanner_switch_2(&children[0], &children[1], &children[2], parse_tree),
            62 => self.scanner_switch_opt_0(&children[0], parse_tree),
            63 => self.scanner_switch_opt_1(parse_tree),
            64 => self.a_s_t_control_0(&children[0], parse_tree),
            65 => self.a_s_t_control_1(&children[0], parse_tree),
            66 => self.cut_operator(&children[0], parse_tree),
            67 => self.user_type_declaration(&children[0], &children[1], parse_tree),
            68 => self.user_type_name(&children[0], &children[1], parse_tree),
            69 => self.user_type_name_list_0(&children[0], &children[1], &children[2], parse_tree),
            70 => self.user_type_name_list_1(parse_tree),
            71 => self.comments(&children[0], parse_tree),
            72 => self.comments_list_0(&children[0], &children[1], parse_tree),
            73 => self.comments_list_group_0(&children[0], parse_tree),
            74 => self.comments_list_group_1(&children[0], parse_tree),
            75 => self.comments_list_1(parse_tree),
            76 => self.line_comment(&children[0], parse_tree),
            77 => self.block_comment(&children[0], parse_tree),
            78 => self.regex(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
